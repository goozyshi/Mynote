# # 每天一道算法题 · 5月

## 学习和实践做题中要掌握一个平衡

2. 解决算法问题的思路
- 注意题目的隐含条件
- 没有思路直接暴力

3. 数据规模
如果要在1s内解决问题：、
- O(n^2)算法可以解决**10^4**级别的数据
- O(n)算法可以解决**10^8**级别的数据
- O(nlogn)算法可以解决**10^7**级别的数据


## 20190505
###  [209. Minimum Size Subarray Sum](https://leetcode.com/problems/minimum-size-subarray-sum/)
给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组。如果不存在符合条件的连续子数组，返回 0。

示例: 
```
输入: s = 7, nums = [2,3,1,2,4,3]
输出: 2
解释: 子数组 [4,3] 是该条件下的长度最小的连续子数组。
```
**【解决】**
```js
/**
 * @思路：滑动窗口方便求和
 * @时间复杂度 O(n)
 * @空间复杂度 O(n)
 */
var minSubArrayLen = function(s, nums) {
  if (nums.length === 0) {
    return 0
  }
  let l = 0
  let r = -1
  let sum = 0
  let min = []
  let res
  while (l < nums.length) {
    if (sum<s) {
      if(r<nums.length-1){
        sum += nums[++ r]
      }else {
        sum -= nums[l ++]
      }
    } else {
      min.push( r - l + 1)
      sum -= nums[l ++]
    }
  }
  res = Math.min(...min)
  return res===Infinity?0:res
};
```
**【另一种】**
```js
/**
 * @思路：简化代码
 * @时间复杂度 O(n)
 * @空间复杂度 O(1)
 */
var minSubArrayLen = function(s, nums) {
  if (s === null || nums.length === 0) {
    return 0
  }
  let l = 0
  let r = 0
  let sum = 0
  let min = Infinity
  while (r < nums.length) {
    sum += nums[r ++]
    while (sum >= s) {
      min = Math.min(min, r-l)
      sum -= nums[l++]
    }
  }
  return min==Infinity?0:min
};
```